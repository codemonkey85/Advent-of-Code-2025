using System.Text;
using Microsoft.CodeAnalysis;

namespace AdventOfCode.TestGenerator;

internal sealed class AocAnswer
{
    public string TypeName { get; set; } = string.Empty;
    public string AssemblyName { get; set; } = string.Empty;
    public string Part1 { get; set; } = string.Empty;
    public string Part2 { get; set; } = string.Empty;
}

[Generator]
public sealed class AocTestGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var answersProvider = context.CompilationProvider
            .Select((compilation, _) => GetAnswers(compilation));

        context.RegisterSourceOutput(answersProvider, (spc, answers) =>
        {
            if (answers == null || answers.Count == 0)
            {
                return;
            }

            var source = GenerateTestsSource(answers);
            spc.AddSource("GeneratedAocTests.g.cs", source);
        });
    }

    private static IReadOnlyList<AocAnswer> GetAnswers(Compilation compilation)
    {
        var list = new List<AocAnswer>();

        var baseDaySymbol = compilation.GetTypeByMetadataName("AoCHelper.BaseDay");
        var attrSymbol = compilation.GetTypeByMetadataName("AdventOfCode.AocExpectedAttribute");

        if (baseDaySymbol == null || attrSymbol == null)
        {
            return list;
        }

        VisitNamespace(compilation.GlobalNamespace);
        return list;

        void VisitNamespace(INamespaceSymbol ns)
        {
            foreach (var member in ns.GetMembers())
            {
                switch (member)
                {
                    case INamespaceSymbol childNs:
                        VisitNamespace(childNs);
                        break;
                    case INamedTypeSymbol { TypeKind: TypeKind.Class } type:
                        ProcessType(type, baseDaySymbol, attrSymbol, list);
                        break;
                }
            }
        }
    }

    private static void ProcessType(
        INamedTypeSymbol type,
        INamedTypeSymbol baseDaySymbol,
        INamedTypeSymbol attrSymbol,
        List<AocAnswer> list)
    {
        if (!DerivesFrom(type, baseDaySymbol))
        {
            return;
        }

        var attr = Enumerable.FirstOrDefault(type.GetAttributes(),
            a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, attrSymbol));

        if (attr == null || attr.ConstructorArguments.Length < 2)
        {
            return;
        }

        var part1 = attr.ConstructorArguments[0].Value?.ToString() ?? string.Empty;
        var part2 = attr.ConstructorArguments[1].Value?.ToString() ?? string.Empty;

        var fullName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        // e.g. "global::AdventOfCode.Day_01" -> "AdventOfCode.Day_01"
        if (fullName.StartsWith("global::", StringComparison.Ordinal))
        {
            fullName = fullName.Substring("global::".Length);
        }

        list.Add(new AocAnswer
        {
            TypeName = fullName, AssemblyName = type.ContainingAssembly.Name, Part1 = part1, Part2 = part2
        });
    }

    private static bool DerivesFrom(INamedTypeSymbol type, INamedTypeSymbol baseType)
    {
        for (var current = type.BaseType; current != null; current = current.BaseType)
        {
            if (SymbolEqualityComparer.Default.Equals(current, baseType))
            {
                return true;
            }
        }

        return false;
    }

    private static string GenerateTestsSource(IReadOnlyList<AocAnswer> answers)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using AoCHelper;");
        sb.AppendLine("using AdventOfCode.Days;");
        sb.AppendLine("using Xunit;");
        sb.AppendLine();
        sb.AppendLine("namespace AdventOfCode.Tests.Generated");
        sb.AppendLine("{");
        sb.AppendLine("    public class GeneratedAocTests");
        sb.AppendLine("    {");

        foreach (var a in answers)
        {
            if (string.IsNullOrWhiteSpace(a.TypeName))
            {
                continue;
            }

            var safeName = a.TypeName.Replace('.', '_').Replace('+', '_');
            var part1 = EscapeForStringLiteral(a.Part1);
            var part2 = EscapeForStringLiteral(a.Part2);

            sb.AppendLine("        [Fact]");
            sb.AppendLine($"        public async Task {safeName}_Part1_real_input_matches_expected()");
            sb.AppendLine("        {");
            sb.AppendLine($"            var day = CreateDayInstance(\"{a.TypeName}\", \"{a.AssemblyName}\");");
            sb.AppendLine("            var result = await day.Solve_1();");
            sb.AppendLine($"            Assert.Equal(\"{part1}\", result);");
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.AppendLine("        [Fact]");
            sb.AppendLine($"        public async Task {safeName}_Part2_real_input_matches_expected()");
            sb.AppendLine("        {");
            sb.AppendLine($"            var day = CreateDayInstance(\"{a.TypeName}\", \"{a.AssemblyName}\");");
            sb.AppendLine("            var result = await day.Solve_2();");
            sb.AppendLine($"            Assert.Equal(\"{part2}\", result);");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        sb.AppendLine("        private static BaseDay CreateDayInstance(string typeName, string assemblyName)");
        sb.AppendLine("        {");
        sb.AppendLine("            var fullName = typeName + \", \" + assemblyName;");
        sb.AppendLine("            var type = Type.GetType(fullName, throwOnError: true);");
        sb.AppendLine("            return (BaseDay)Activator.CreateInstance(type)!;");
        sb.AppendLine("        }");

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string EscapeForStringLiteral(string value) =>
        string.IsNullOrEmpty(value)
            ? string.Empty
            : value.Replace("\\", @"\\").Replace("\"", "\\\"");
}
